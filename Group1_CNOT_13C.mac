#########################################################
# 
# Group1_CNOT_13C
#
# A pulse sequence suitable for performing the Group1_CNOT_13C experiment,
# Polarization transferred from Proton to Carbon.
#
#  H  90-d-180-d--90----
#  C  ---d-180-d--90-acq
#
# Copyright (c) Magritek Ltd 2022
#
# U.I. V5
#########################################################

#########################################################
# 
# The is the entry point for the SpinsolveExpert 
# interface. It will add the experiment to the parameter
# list or with the control key pressed open the
# relevant macros in the pulse program compiler.
#
# Autogenerated 
#
#########################################################

procedure(Group1_CNOT_13C, parameters=null)

   macroLocation = getmacropath()
   parentPath = getbasepath(macroLocation)
   ppGroup = getbasedir(parentPath)

   if(iskeypressed("shift"))
      PulseProgramCompiler(guiwinnr(),null,parentPath,"Group1_CNOT_13C")
   elseif(iskeypressed("control"))
      gView->showExperimentHelp("Group1_CNOT_13C")
   else
      gExpt->addExperiment(ppGroup,"Group1_CNOT_13C",parameters)
   endif

endproc()

#########################################################
# 
# Provide a backdoor interface to this macro. This 
# adds [""] to the user interface list (guipar)
# and also generates the pulse program lists required 
# by execpp. Finally is calls execpp, returning any
# results in the structure 'r'.
#
# Autogenerated 
#
#########################################################

procedure(backdoor, guipar)

   seqInfo = :getseqpar()  
   r = gSeq->initAndRunPP(getmacropath(), getmacroname(), guipar, seqInfo)

endproc(r)

#########################################################
# 
# Returns important pulse sequence parameter lists
#
# rel ......... relationship between pulse sequence parameters
# var ......... variable which change during the pulse sequence
# pp_list ..... list of pulse sequence parameters sent to DSP
# pp_name ..... name of DSP pulse program to run
# phase_list .. phase cycling information
#
# Autogenerated 
#
#########################################################

procedure(getseqpar)

   rel = ["b1Freq        = b1Freq13C",
          "n1            = nrPnts",
          "a90H          = 90Amplitude1H",
          "d90H          = pulseLength1H",
          "d90C          = pulseLength13C",
          "a90HC         = 90AmplitudeHC",
          "a90C          = 90Amplitude13C",
          "dEvolution    = 1e3*dEvolution-pgo",
          "dAcq          = acqDelay",
          "offFreq13C    = (centerFreqPPM13C-wvPPMOffset13C)*b1Freq13C",
          "offFreq1H     = (centerFreqPPM1H-wvPPMOffset1H)*b1Freq1H",
          "b1FreqTxCh1   = double(b1Freq1H)+double(offFreq1H/1e6d)",
          "b1FreqTxCh2   = double(b1Freq13C)+double(offFreq13C/1e6d)",
          "b1FreqRx      = b1FreqTxCh2",
          "freq1H        = b1FreqTxCh1",
          "freq13C       = b1FreqTxCh2",
          "totPnts       = nrPnts",
          "totTime       = acqTime"]
   var = [""]
   pp_list = ["n1","a90C","p1","d90C","a90H","p4","d90H","p3","p2","dEvolution","dAcq"]
   pp_name = "Group1_CNOT_13C.p"
   phase_list = [1,3,1,3;0,2,0,2;3,1,3,1;2,0,2,0;0,2,0,2]

   seqInfo = struct(rel,var,pp_list,pp_name,phase_list)

endproc(seqInfo)


########################################################
# Execute the pulse program, collecting nrScans of 
# data and displaying the result in the 1D plot. 
#
# This procedure can be modified to perform more
# complex functions using the passed parameters:
#
# guipar ..... all parameters from the user interface
# ppList ..... the pulse program parameter list
# pcList ..... phase-cycle list
# pcIndex .... indices of phase parameters in ppList
# varIndex ... indices of variable parameters in ppList
#
# 15-June-2020 CDE
#
########################################################

procedure(execpp,guipar,ppList,pcList,pcIndex,varIndex)

# Make all gui parameters available
   assignlist(guipar)

# Allocate space for output data
   sumData = cmatrix(totPnts)

# Calculate suitable time and frequency axes
   tAxis = ([0:1:totPnts-1]/totPnts)*totTime*1000 # ms
   fAxis = [-totPnts*zf/2:totPnts*zf/2-1]/(totTime*zf)*1000 # Hz

# Time domain filter
   if(filter == "yes")
      flt = filters:get_filter(filterType,"FTFid",tAxis/1e6)
   else
      flt = matrix(totPnts)+1
   endif

# Get plot regions
   (prt,prf) = ucsPlot:getPlotReferences()
   prt->showimag("true")
   prf->showimag("false")

# Work out frequency axis scale, label and range
   (fAxisDisp,fAxisLabel,fRange) = ucsPlot:generate1DFrequencyAxis(prf, fAxis, b1Freq13C, wvPPMOffset13C, offFreq13C, guipar)
   
# Accumulate scan
   for(scan = 0 to nrScans-1)
   
    # Set phases for this scan
      (ppList,pAcq) = ucsRun:setPPPhase(ppList,scan,pcList,pcIndex)

    # Send phase parameters to DSP
       ucsRun:updatePPParameters(ppList,guipar,wvPort)  

    # Wait for repetition time and check for abort
      check = ucsRun:checkTiming(guipar,scan,pcList)
      if(check == "abort")
         return(0)
      endif

    # Run the pulse program and collect the data
       ucsUtilities:suspendLock() # turn lock control loop off
      (status,data) = ucsRun:getData(totPnts,guipar)
       ucsUtilities:resumeLock()  # turn lock control loop on

    # See if stop button/escape key pressed
      if(status != "ok")
         return(0)
      endif

      data = shift(data,round(shiftPoints))   # shift data by shiftPoints

    # Accumlate the data
      sumData = ucsRun:accumulate(accumulate,pAcq,sumData,data)

    # Correct the first data point
      datacorr = sumData
      if (shiftPoints == 1)
         datacorr = ucsUtilities:correctFirstPointAmpPhase(sumData)
         datacorr[0] = datacorr[0]/2
      endif

    # FID autophase
      #phCor = phase(datacorr[0])
      #datacorr = datacorr*exp(-i*phCor)

    # Process data
      (phasedTimeData,spectrum,ph0) = ucsRun:transformData(zerofill(datacorr.*flt,zf*totPnts,"end"),fAxis,guipar,"fid")
    
    # Plot the data 
      ucsPlot:graphTimeAndFreq(prt,prf,tAxis,datacorr,fAxisDisp,spectrum,scan,guipar,
                               "Time data","Spectral data",
                               "Time (ms)","Amplitude (\G(m)V)",
                               fAxisLabel,"Amplitude")

    # Check if complete button pressed
      if(check == "finish")
         scan = scan+1
         exitfor()
      endif

   next(scan)

# Save the data
   ucsFiles:savePlot(prt,:getPlotInfo("pt1"),guipar,"noReport")
   ucsFiles:savePlot(prf,:getPlotInfo("pt2"),guipar,"simpleReport")
   ucsFiles:saveMNovaData(prt,:getPlotInfo("pt1"),guipar,"simpleReport",phase0=ph0)

# Save the processing parameters
   :saveProcPar(guipar,ph0,fRange)

# Pack the data into a structure
   result = struct()
   result->tx = tAxis
   result->ty = datacorr/scan
   result->fx = fAxisDisp
   result->fy = spectrum/scan
   result->par = struct(guipar)

# Return result
   return(result)

endproc("execpp")

########################################################
# Return expected experiment duration
########################################################

procedure(expectedDuration, guipar)

   assignstruct(guipar)
   totScans = nrScans + useStartDelay
   duration = totScans*repTime/1000
   
endproc(duration)

########################################################
# Get the name of a plot file given the region name
# or return the whole list
########################################################

procedure(getPlotInfo,plotRegion)

   info = ["pt1","fid.pt1","pt2","spectrum.pt1"]

   if(plotRegion == "all")
      return(info)
   endif

   idx = getlistindex(info,plotRegion)
   if(idx != -1)
      return(info[idx+1])
   endif

endproc(null)


########################################################
# Calculate the phase and amplitude table
########################################################

procedure(getSoftRF,w1,a1,OffFreq)

   n1=8192  #number of steps
   d1=w1/n1   #step time
 

   sp=cmatrix(n1)

   a1 = ucsRun:convertTxGain(a1)
   
   OffFreq = single(OffFreq)

   k = [0:n1-1]

   sp[k] = a1*exp(i*2*pi*OffFreq*d1*1e-6*k)

   tamp = mag(sp)
   tphase = 32768/pi*phase(sp)

endproc(tphase,tamp,n1,d1)
   

########################################################
# Save the processing parameters
########################################################

procedure(saveProcPar,guipar,p0,xrange)

   assignlist(guipar)
  
   if(saveData == "false")
      return
   endif

   if(usePPMScale == "yes")
      xrange = xrange*single(b1Freq13C)
   endif 

   procpar = ["apodizationFunction = \"$filterType$\"",
              "baseLineCorrectionMethod = \"None\"",
              "displayInPPM = \"$usePPMScale$\"",
              "ftOrigin = \"Start\"",
              "ftType = \"Complex\"",
              "p0Phase = $p0$",
              "p1Phase = 0",
              "p1Pivot = 0",
              "p1FixedPhase = 0",
              "phaseMethod = \"p0, p1 fixed phase\"",
              "ppmOffset = $centerFreqPPM13C$",
              "zeroFill = $zf$",
              "plotWidth = $xrange[1]-xrange[0]$",
              "plotStart = $xrange[0]$",
              "shiftPoints = 1"]


   cd("$dataDirectory$\\$expName$")
   if(isfile("proc.par"))
      par = load("proc.par")
      procpar = mergelists(procpar,par)
   endif

   save("proc.par",procpar)

   if(isfile("proc_temp.par"))
      rmfile("proc_temp.par")
   endif

endproc()
